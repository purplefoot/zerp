! Basic unit tests to confirm zerp functionality
! 
! Pretty much everything is written in assembler here, to keep things
! as close to the virtual metal as possible.

Global zerp1 = 0;
Global zerp2 = 0;

[Main x;
    print "Zerp unit test suite v0.1^";
    print "^If you can see this then printing works.";
    print "^The sets are kept in routines for ease of maintainence - so CALL needs to work.^Testing CALL...";
    x = basic_call();
    print "Back in main. Routine should have returned 1, it returned ", x;
    print "^^Beginning tests.....^";
    branch_tests();
    simple_store_tests();
    local_tests();
    @quit;
];

[basic_call;
    print "works.^";
    @rtrue;
];

[branch_tests;
    print "Testing branch instructions^";
    test_branch_je();
    test_branch_jl();
    test_branch_jg();
    test_branch_jz();
    test_branch_return();
];

[test_branch_je;
    print "Testing JE^";
    print "JE 1 1...";
    @je 1 1 ?ok;
    jump fail;
.ok;
    print "ok^";
    print "JE@@126 1 1...";
    @je 1 1 ?~fail;
    print "ok^";
    print "JE 1 2...";
    @je 1 2 ?fail;
    print "ok^";
    print "JE@@126 1 2...";
    @je 1 2 ?~ok2;
    jump fail;
.ok2;
    print "ok^";
    print "JE 1 1 2 3...";
    @je 1 1 2 3 ?ok3;
    jump fail;
.ok3;
    print "ok^";
    print "JE@@126 1 1 2 3...";
    @je 1 1 2 3 ?~fail;
    print "ok^";
    print "JE 3 1 2 3...";
    @je 3 1 2 3 ?ok4;
    jump fail;
.ok4;
    print "ok^";
    print "JE 1234 1234...";
    @je 1234 1234 ?ok5;
    jump fail;
.ok5;
    print "ok^";
    print "JE@@126 1234 1234...";
    @je 1234 1234 ?~fail;
    print "ok^";
    print "JE 1234 4321...";
    @je 1234 4321 ?fail;
    print "ok^";
    print "JE@@126 1234 4321...";
    @je 1234 4321 ?~ok6;
    jump fail;
.ok6;
    print "ok^";    
    rtrue;
.fail;
    print "fail^";
    rfalse;
];

[test_branch_jl;
    print "Testing JL^";
    print "JL 1 2...";
    @jl 1 2 ?ok;
    jump fail;
.ok;
    print "ok^";
    print "JL@@126 1 2...";
    @jl 1 2 ?~fail;
    print "ok^";
    print "JL 2 1...";
    @jl 2 1 ?fail;
    print "ok^";
    print "JL@@126 2 1...";
    @jl 2 1 ?~ok2;
    jump fail;
.ok2;
    print "ok^";
    print "JL 1 1...";
    @jl 1 1 ?fail;
    print "ok^";
    print "JL@@126 1 1...";
    @jl 1 1 ?~ok4;
    jump fail;
.ok4;
    print "ok^";
    print "JL -1 1...";
    @jl -1 1 ?ok5;
    jump fail;
.ok5;
    print "ok^";
    print "JL@@126 -1 1...";
    @jl -1 1 ?~fail;
    print "ok^";
    print "JL -1 32655...";
    @jl -1 32655 ?ok6;
    jump fail;
.ok6;
    print "ok^";
    print "JL@@126 -1 32655...";
    @jl -1 32655 ?~fail;
    print "ok^";
    rtrue;
.fail;
    print "fail^";
    rfalse;
];

[test_branch_jg;
    print "Testing JG^";
    print "JG 2 1...";
    @jg 2 1 ?ok;
    jump fail;
.ok;
    print "ok^";
    print "JG@@126 2 1...";
    @jg 2 1 ?~fail;
    print "ok^";
    print "JG 1 2...";
    @jg 1 2 ?fail;
    print "ok^";
    print "JG@@126 1 2...";
    @jg 1 2 ?~ok2;
    jump fail;
.ok2;
    print "ok^";
    print "JG 1 1...";
    @jg 1 1 ?fail;
    print "ok^";
    print "JG@@126 1 1...";
    @jg 1 1 ?~ok4;
    jump fail;
.ok4;
    print "ok^";
    print "JG -1 1...";
    @jg 1 (-1) ?ok5;
    jump fail;
.ok5;
    print "ok^";
    print "JG@@126 1 -1...";
    @jg 1 (-1) ?~fail;
    print "ok^";
    print "JG 32655 -1...";
    @jg 32655 (-1) ?ok6;
    jump fail;
.ok6;
    print "ok^";
    print "JG@@126 32655 -1...";
    @jg 32655 (-1) ?~fail;
    print "ok^";
    rtrue;
.fail;
    print "fail^";
    rfalse;
];

[test_branch_jz;
    print "Testing Jz^";
    print "JZ 0...";
    @jz 0 ?ok;
    jump fail;
.ok;
    print "ok^";
    print "JZ@@126 0...";
    @jz 0 ?~fail;
    print "ok^";
    rtrue;
.fail;
    print "fail^";
    rfalse;
];

[test_branch_return;
    print "Return true on branch...";
    zerp1 = branch_return_true();
    @je zerp1 1 ?~fail;
    print "ok^";
    print "Return false on branch...";
    zerp1 = branch_return_false();
    @je zerp1 0 ?~fail;
    print_ret "ok";
.fail;
    print "fail^";
    rfalse;
];

[branch_return_true;
    @je 1 1 ?rtrue;
    rfalse;
];

[branch_return_false;
    @je 1 1 ?rfalse;
    rtrue;
];

[simple_store_tests;
    print "Testing basic storage^";
    print "zerp1 = ", zerp1;
    new_line;
    print "STORE zerp1 ab...";
    @store zerp1 $ab;
    @je zerp1 $ab ?~fail;
    print "ok^";
    print "STORE zerp1 abab...";
    @store zerp1 $abab;
    @je zerp1 $abab ?~fail;
    print "ok^";
    print "LOAD zerp1 -> zerp2...";
    @load zerp1 -> zerp2;
    @je zerp1 zerp2 ?~fail;
    print "ok^";
    rtrue;
.fail;
    print "fail: ", zerp1;
    new_line;
    rfalse;
];

[local_tests a b c d e;
    print "testing locals^";
    @store zerp1 $aaaa;
    @store a 1;
    @store b $ff;
    @store c $ffff;
    @store d zerp1;
    print "a = 1...";
    @je a 1 ?~fail;
    print "ok^b = 0xff...";
    @je b $ff ?~fail;
    print "ok^c = 0xffff...";
    @je c $ffff ?~fail;
    print "ok^d = [G00]...";
    @je d $aaaa ?~fail;
    print "ok^";
    e = stack_locals();
    print "Should have returned 1 on success...";
    @je e 1 ?~fail;
    print "ok^Locals should be restored...^";
    print "a = 1...";
    @je a 1 ?~fail;
    print "ok^b = 0xff...";
    @je b $ff ?~fail;
    print "ok^c = 0xffff...";
    @je c $ffff ?~fail;
    print "ok^";
    rtrue;
.fail;
    print "fail^";
    rfalse;
];

[stack_locals x y z w;
    print "testing local in a new frame^Check defaults are zero...";
    @jz x ?~fail;
    @jz y ?~fail;
    @jz z ?~fail;
    print "ok^Write and read some new values...^";
    @store zerp2 $cccc;
    @store x 9;
    @store y $bb;
    @store z $eeee;
    @store w zerp2;
    print "x = 9...";
    @je x 9 ?~fail;
    print "ok^y = 0xbb...";
    @je y $bb ?~fail;
    print "ok^c = 0xffff...";
    @je z $eeee ?~fail;
    print "ok^w = [G00]...";
    @je w $cccc ?~fail;
    print "ok^";
    rtrue;
.fail;
    print "fail^";
    rfalse;
];